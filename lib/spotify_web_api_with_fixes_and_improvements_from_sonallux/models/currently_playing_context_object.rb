# spotify_web_api_with_fixes_and_improvements_from_sonallux
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module SpotifyWebApiWithFixesAndImprovementsFromSonallux
  # CurrentlyPlayingContextObject Model.
  class CurrentlyPlayingContextObject < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The device that is currently active.
    # @return [DeviceObject]
    attr_accessor :device

    # off, track, context
    # @return [String]
    attr_accessor :repeat_state

    # If shuffle is on or off.
    # @return [TrueClass | FalseClass]
    attr_accessor :shuffle_state

    # A Context Object. Can be `null`.
    # @return [ContextObject]
    attr_accessor :context

    # Unix Millisecond Timestamp when data was fetched.
    # @return [Integer]
    attr_accessor :timestamp

    # Progress into the currently playing track or episode. Can be `null`.
    # @return [Integer]
    attr_accessor :progress_ms

    # If something is currently playing, return `true`.
    # @return [TrueClass | FalseClass]
    attr_accessor :is_playing

    # The currently playing track or episode. Can be `null`.
    # @return [Object]
    attr_accessor :item

    # The object type of the currently playing item. Can be one of `track`,
    # `episode`, `ad` or `unknown`.
    # @return [String]
    attr_accessor :currently_playing_type

    # Allows to update the user interface based on which playback actions are
    # available within the current context.
    # @return [DisallowsObject]
    attr_accessor :actions

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['device'] = 'device'
      @_hash['repeat_state'] = 'repeat_state'
      @_hash['shuffle_state'] = 'shuffle_state'
      @_hash['context'] = 'context'
      @_hash['timestamp'] = 'timestamp'
      @_hash['progress_ms'] = 'progress_ms'
      @_hash['is_playing'] = 'is_playing'
      @_hash['item'] = 'item'
      @_hash['currently_playing_type'] = 'currently_playing_type'
      @_hash['actions'] = 'actions'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        device
        repeat_state
        shuffle_state
        context
        timestamp
        progress_ms
        is_playing
        item
        currently_playing_type
        actions
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(device = SKIP, repeat_state = SKIP, shuffle_state = SKIP,
                   context = SKIP, timestamp = SKIP, progress_ms = SKIP,
                   is_playing = SKIP, item = SKIP,
                   currently_playing_type = SKIP, actions = SKIP)
      @device = device unless device == SKIP
      @repeat_state = repeat_state unless repeat_state == SKIP
      @shuffle_state = shuffle_state unless shuffle_state == SKIP
      @context = context unless context == SKIP
      @timestamp = timestamp unless timestamp == SKIP
      @progress_ms = progress_ms unless progress_ms == SKIP
      @is_playing = is_playing unless is_playing == SKIP
      @item = item unless item == SKIP
      @currently_playing_type = currently_playing_type unless currently_playing_type == SKIP
      @actions = actions unless actions == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      device = DeviceObject.from_hash(hash['device']) if hash['device']
      repeat_state = hash.key?('repeat_state') ? hash['repeat_state'] : SKIP
      shuffle_state = hash.key?('shuffle_state') ? hash['shuffle_state'] : SKIP
      context = ContextObject.from_hash(hash['context']) if hash['context']
      timestamp = hash.key?('timestamp') ? hash['timestamp'] : SKIP
      progress_ms = hash.key?('progress_ms') ? hash['progress_ms'] : SKIP
      is_playing = hash.key?('is_playing') ? hash['is_playing'] : SKIP
      item = hash.key?('item') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:CurrentlyPlayingContextObjectItem), hash['item']
      ) : SKIP
      currently_playing_type =
        hash.key?('currently_playing_type') ? hash['currently_playing_type'] : SKIP
      actions = DisallowsObject.from_hash(hash['actions']) if hash['actions']

      # Create object from extracted values.
      CurrentlyPlayingContextObject.new(device,
                                        repeat_state,
                                        shuffle_state,
                                        context,
                                        timestamp,
                                        progress_ms,
                                        is_playing,
                                        item,
                                        currently_playing_type,
                                        actions)
    end

    # Validates an instance of the object from a given value.
    # @param [CurrentlyPlayingContextObject | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} device: #{@device}, repeat_state: #{@repeat_state}, shuffle_state:"\
      " #{@shuffle_state}, context: #{@context}, timestamp: #{@timestamp}, progress_ms:"\
      " #{@progress_ms}, is_playing: #{@is_playing}, item: #{@item}, currently_playing_type:"\
      " #{@currently_playing_type}, actions: #{@actions}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} device: #{@device.inspect}, repeat_state: #{@repeat_state.inspect},"\
      " shuffle_state: #{@shuffle_state.inspect}, context: #{@context.inspect}, timestamp:"\
      " #{@timestamp.inspect}, progress_ms: #{@progress_ms.inspect}, is_playing:"\
      " #{@is_playing.inspect}, item: #{@item.inspect}, currently_playing_type:"\
      " #{@currently_playing_type.inspect}, actions: #{@actions.inspect}>"
    end
  end
end
