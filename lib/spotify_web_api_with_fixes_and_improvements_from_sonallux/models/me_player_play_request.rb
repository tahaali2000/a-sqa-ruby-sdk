# spotify_web_api_with_fixes_and_improvements_from_sonallux
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module SpotifyWebApiWithFixesAndImprovementsFromSonallux
  # MePlayerPlayRequest Model.
  class MePlayerPlayRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Optional. Spotify URI of the context to play.
    # Valid contexts are albums, artists & playlists.
    # `{context_uri:"spotify:album:1Je1IMUlBXcx1Fz0WE7oPT"}`
    # @return [String]
    attr_accessor :context_uri

    # Optional. A JSON array of the Spotify track URIs to play.
    # For example: `{"uris": ["spotify:track:4iV5W9uYEdYUVa79Axb7Rh",
    # "spotify:track:1301WleyT98MSxVHPZCA6M"]}`
    # @return [Array[String]]
    attr_accessor :uris

    # Optional. Indicates from where in the context playback should start. Only
    # available when context_uri corresponds to an album or playlist object
    # "position" is zero based and canâ€™t be negative. Example: `"offset":
    # {"position": 5}`
    # "uri" is a string representing the uri of the item to start at. Example:
    # `"offset": {"uri": "spotify:track:1301WleyT98MSxVHPZCA6M"}`
    # @return [Object]
    attr_accessor :offset

    # Indicates from what position to start playback. Must be a positive number.
    # Passing in a position that is greater than the length of the track will
    # cause the player to start playing the next song.
    # @return [Integer]
    attr_accessor :position_ms

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['context_uri'] = 'context_uri'
      @_hash['uris'] = 'uris'
      @_hash['offset'] = 'offset'
      @_hash['position_ms'] = 'position_ms'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        context_uri
        uris
        offset
        position_ms
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(context_uri = SKIP, uris = SKIP, offset = SKIP,
                   position_ms = SKIP)
      @context_uri = context_uri unless context_uri == SKIP
      @uris = uris unless uris == SKIP
      @offset = offset unless offset == SKIP
      @position_ms = position_ms unless position_ms == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      context_uri = hash.key?('context_uri') ? hash['context_uri'] : SKIP
      uris = hash.key?('uris') ? hash['uris'] : SKIP
      offset = hash.key?('offset') ? hash['offset'] : SKIP
      position_ms = hash.key?('position_ms') ? hash['position_ms'] : SKIP

      # Create object from extracted values.
      MePlayerPlayRequest.new(context_uri,
                              uris,
                              offset,
                              position_ms)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} context_uri: #{@context_uri}, uris: #{@uris}, offset: #{@offset},"\
      " position_ms: #{@position_ms}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} context_uri: #{@context_uri.inspect}, uris: #{@uris.inspect}, offset:"\
      " #{@offset.inspect}, position_ms: #{@position_ms.inspect}>"
    end
  end
end
