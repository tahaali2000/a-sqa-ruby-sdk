# spotify_web_api_with_fixes_and_improvements_from_sonallux
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module SpotifyWebApiWithFixesAndImprovementsFromSonallux
  # TrackObject Model.
  class TrackObject < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The album on which the track appears. The album object includes a link in
    # `href` to full information about the album.
    # @return [SimplifiedAlbumObject]
    attr_accessor :album

    # The artists who performed the track. Each artist object includes a link in
    # `href` to more detailed information about the artist.
    # @return [Array[ArtistObject]]
    attr_accessor :artists

    # A list of the countries in which the track can be played, identified by
    # their [ISO 3166-1
    # alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
    # @return [Array[String]]
    attr_accessor :available_markets

    # The disc number (usually `1` unless the album consists of more than one
    # disc).
    # @return [Integer]
    attr_accessor :disc_number

    # The track length in milliseconds.
    # @return [Integer]
    attr_accessor :duration_ms

    # Whether or not the track has explicit lyrics ( `true` = yes it does;
    # `false` = no it does not OR unknown).
    # @return [TrueClass | FalseClass]
    attr_accessor :explicit

    # Known external IDs for the track.
    # @return [ExternalIdObject]
    attr_accessor :external_ids

    # Known external URLs for this track.
    # @return [ExternalUrlObject]
    attr_accessor :external_urls

    # A link to the Web API endpoint providing full details of the track.
    # @return [String]
    attr_accessor :href

    # The [Spotify ID](/documentation/web-api/concepts/spotify-uris-ids) for the
    # track.
    # @return [String]
    attr_accessor :id

    # Part of the response when [Track
    # Relinking](/documentation/web-api/concepts/track-relinking) is applied. If
    # `true`, the track is playable in the given market. Otherwise `false`.
    # @return [TrueClass | FalseClass]
    attr_accessor :is_playable

    # Part of the response when [Track
    # Relinking](/documentation/web-api/concepts/track-relinking) is applied,
    # and the requested track has been replaced with different track. The track
    # in the `linked_from` object contains information about the originally
    # requested track.
    # @return [LinkedTrackObject]
    attr_accessor :linked_from

    # Included in the response when a content restriction is applied.
    # @return [TrackRestrictionObject]
    attr_accessor :restrictions

    # The name of the track.
    # @return [String]
    attr_accessor :name

    # The popularity of the track. The value will be between 0 and 100, with 100
    # being the most popular.<br/>The popularity of a track is a value between 0
    # and 100, with 100 being the most popular. The popularity is calculated by
    # algorithm and is based, in the most part, on the total number of plays the
    # track has had and how recent those plays are.<br/>Generally speaking,
    # songs that are being played a lot now will have a higher popularity than
    # songs that were played a lot in the past. Duplicate tracks (e.g. the same
    # track from a single and an album) are rated independently. Artist and
    # album popularity is derived mathematically from track popularity.
    # _**Note**: the popularity value may lag actual popularity by a few days:
    # the value is not updated in real time._
    # @return [Integer]
    attr_accessor :popularity

    # A link to a 30 second preview (MP3 format) of the track. Can be `null`
    # @return [String]
    attr_accessor :preview_url

    # The number of the track. If an album has several discs, the track number
    # is the number on the specified disc.
    # @return [Integer]
    attr_accessor :track_number

    # The object type: "track".
    # @return [Type2Enum]
    attr_accessor :type

    # The [Spotify URI](/documentation/web-api/concepts/spotify-uris-ids) for
    # the track.
    # @return [String]
    attr_accessor :uri

    # Whether or not the track is from a local file.
    # @return [TrueClass | FalseClass]
    attr_accessor :is_local

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['album'] = 'album'
      @_hash['artists'] = 'artists'
      @_hash['available_markets'] = 'available_markets'
      @_hash['disc_number'] = 'disc_number'
      @_hash['duration_ms'] = 'duration_ms'
      @_hash['explicit'] = 'explicit'
      @_hash['external_ids'] = 'external_ids'
      @_hash['external_urls'] = 'external_urls'
      @_hash['href'] = 'href'
      @_hash['id'] = 'id'
      @_hash['is_playable'] = 'is_playable'
      @_hash['linked_from'] = 'linked_from'
      @_hash['restrictions'] = 'restrictions'
      @_hash['name'] = 'name'
      @_hash['popularity'] = 'popularity'
      @_hash['preview_url'] = 'preview_url'
      @_hash['track_number'] = 'track_number'
      @_hash['type'] = 'type'
      @_hash['uri'] = 'uri'
      @_hash['is_local'] = 'is_local'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        album
        artists
        available_markets
        disc_number
        duration_ms
        explicit
        external_ids
        external_urls
        href
        id
        is_playable
        linked_from
        restrictions
        name
        popularity
        preview_url
        track_number
        type
        uri
        is_local
      ]
    end

    # An array for nullable fields
    def self.nullables
      %w[
        preview_url
      ]
    end

    def initialize(album = SKIP, artists = SKIP, available_markets = SKIP,
                   disc_number = SKIP, duration_ms = SKIP, explicit = SKIP,
                   external_ids = SKIP, external_urls = SKIP, href = SKIP,
                   id = SKIP, is_playable = SKIP, linked_from = SKIP,
                   restrictions = SKIP, name = SKIP, popularity = SKIP,
                   preview_url = SKIP, track_number = SKIP, type = SKIP,
                   uri = SKIP, is_local = SKIP)
      @album = album unless album == SKIP
      @artists = artists unless artists == SKIP
      @available_markets = available_markets unless available_markets == SKIP
      @disc_number = disc_number unless disc_number == SKIP
      @duration_ms = duration_ms unless duration_ms == SKIP
      @explicit = explicit unless explicit == SKIP
      @external_ids = external_ids unless external_ids == SKIP
      @external_urls = external_urls unless external_urls == SKIP
      @href = href unless href == SKIP
      @id = id unless id == SKIP
      @is_playable = is_playable unless is_playable == SKIP
      @linked_from = linked_from unless linked_from == SKIP
      @restrictions = restrictions unless restrictions == SKIP
      @name = name unless name == SKIP
      @popularity = popularity unless popularity == SKIP
      @preview_url = preview_url unless preview_url == SKIP
      @track_number = track_number unless track_number == SKIP
      @type = type unless type == SKIP
      @uri = uri unless uri == SKIP
      @is_local = is_local unless is_local == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      album = SimplifiedAlbumObject.from_hash(hash['album']) if hash['album']
      # Parameter is an array, so we need to iterate through it
      artists = nil
      unless hash['artists'].nil?
        artists = []
        hash['artists'].each do |structure|
          artists << (ArtistObject.from_hash(structure) if structure)
        end
      end

      artists = SKIP unless hash.key?('artists')
      available_markets =
        hash.key?('available_markets') ? hash['available_markets'] : SKIP
      disc_number = hash.key?('disc_number') ? hash['disc_number'] : SKIP
      duration_ms = hash.key?('duration_ms') ? hash['duration_ms'] : SKIP
      explicit = hash.key?('explicit') ? hash['explicit'] : SKIP
      external_ids = ExternalIdObject.from_hash(hash['external_ids']) if hash['external_ids']
      external_urls = ExternalUrlObject.from_hash(hash['external_urls']) if hash['external_urls']
      href = hash.key?('href') ? hash['href'] : SKIP
      id = hash.key?('id') ? hash['id'] : SKIP
      is_playable = hash.key?('is_playable') ? hash['is_playable'] : SKIP
      linked_from = LinkedTrackObject.from_hash(hash['linked_from']) if hash['linked_from']
      restrictions = TrackRestrictionObject.from_hash(hash['restrictions']) if
        hash['restrictions']
      name = hash.key?('name') ? hash['name'] : SKIP
      popularity = hash.key?('popularity') ? hash['popularity'] : SKIP
      preview_url = hash.key?('preview_url') ? hash['preview_url'] : SKIP
      track_number = hash.key?('track_number') ? hash['track_number'] : SKIP
      type = hash.key?('type') ? hash['type'] : SKIP
      uri = hash.key?('uri') ? hash['uri'] : SKIP
      is_local = hash.key?('is_local') ? hash['is_local'] : SKIP

      # Create object from extracted values.
      TrackObject.new(album,
                      artists,
                      available_markets,
                      disc_number,
                      duration_ms,
                      explicit,
                      external_ids,
                      external_urls,
                      href,
                      id,
                      is_playable,
                      linked_from,
                      restrictions,
                      name,
                      popularity,
                      preview_url,
                      track_number,
                      type,
                      uri,
                      is_local)
    end

    # Validates an instance of the object from a given value.
    # @param [TrackObject | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} album: #{@album}, artists: #{@artists}, available_markets:"\
      " #{@available_markets}, disc_number: #{@disc_number}, duration_ms: #{@duration_ms},"\
      " explicit: #{@explicit}, external_ids: #{@external_ids}, external_urls: #{@external_urls},"\
      " href: #{@href}, id: #{@id}, is_playable: #{@is_playable}, linked_from: #{@linked_from},"\
      " restrictions: #{@restrictions}, name: #{@name}, popularity: #{@popularity}, preview_url:"\
      " #{@preview_url}, track_number: #{@track_number}, type: #{@type}, uri: #{@uri}, is_local:"\
      " #{@is_local}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} album: #{@album.inspect}, artists: #{@artists.inspect}, available_markets:"\
      " #{@available_markets.inspect}, disc_number: #{@disc_number.inspect}, duration_ms:"\
      " #{@duration_ms.inspect}, explicit: #{@explicit.inspect}, external_ids:"\
      " #{@external_ids.inspect}, external_urls: #{@external_urls.inspect}, href:"\
      " #{@href.inspect}, id: #{@id.inspect}, is_playable: #{@is_playable.inspect}, linked_from:"\
      " #{@linked_from.inspect}, restrictions: #{@restrictions.inspect}, name: #{@name.inspect},"\
      " popularity: #{@popularity.inspect}, preview_url: #{@preview_url.inspect}, track_number:"\
      " #{@track_number.inspect}, type: #{@type.inspect}, uri: #{@uri.inspect}, is_local:"\
      " #{@is_local.inspect}>"
    end
  end
end
